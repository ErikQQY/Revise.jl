<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How Revise works · Revise.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Revise.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../config/">Configuration</a></li><li><a class="toctext" href="../cookbook/">Revise usage: a cookbook</a></li><li><a class="toctext" href="../limitations/">Limitations</a></li><li><a class="toctext" href="../debugging/">Debugging Revise</a></li><li class="current"><a class="toctext" href>How Revise works</a><ul class="internal"><li><a class="toctext" href="#The-structure-of-Revise&#39;s-internal-representation-1">The structure of Revise&#39;s internal representation</a></li></ul></li><li><a class="toctext" href="../user_reference/">User reference</a></li><li><a class="toctext" href="../dev_reference/">Developer reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>How Revise works</a></li></ul><a class="edit-page" href="https://github.com/timholy/Revise.jl/blob/master/docs/src/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>How Revise works</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="How-Revise-works-1" href="#How-Revise-works-1">How Revise works</a></h1><p>In addition to the material below, see these talks:</p><ul><li><a href="https://www.youtube.com/watch?v=KuM0AGaN09s">JuliaCon 2018</a></li><li><a href="https://www.youtube.com/watch?v=gXDI4DSp04c">JuliaCon 2019</a></li></ul><p>Revise is based on the fact that you can change functions even when they are defined in other modules. Here&#39;s an example showing how you do that manually (without using Revise):</p><pre><code class="language-julia">julia&gt; convert(Float64, π)
3.141592653589793

julia&gt; # That&#39;s too hard, let&#39;s make life easier for students

julia&gt; @eval Base convert(::Type{Float64}, x::Irrational{:π}) = 3.0
convert (generic function with 714 methods)

julia&gt; convert(Float64, π)
3.0</code></pre><p>Revise removes some of the tedium of manually copying and pasting code into <code>@eval</code> statements. To decrease the amount of re-JITting required, Revise avoids reloading entire modules; instead, it takes care to <code>eval</code> only the <em>changes</em> in your package(s), much as you would if you were doing it manually. Importantly, changes are detected in a manner that is independent of the specific line numbers in your code, so that you don&#39;t have to re-evaluate just because code moves around within the same file. (One unfortunate side effect is that line numbers may become inaccurate in backtraces, but Revise takes pains to correct these, see below.)</p><p>To accomplish this, Revise uses the following overall strategy:</p><ul><li>add callbacks to Base so that Revise gets notified when new packages are loaded or new files <code>include</code>d</li><li>prepare source-code caches for every new file. These caches will allow Revise to detect changes when files are updated. For precompiled packages this happens on an as-needed basis, using the cached source in the <code>*.ji</code> file. For non-precompiled packages, Revise parses the source for each <code>include</code>d file immediately so that the initial state is known and changes can be detected.</li><li>monitor the file system for changes to any of the dependent files; it immediately appends any updates to a list of file names that need future processing</li><li>intercept the REPL&#39;s backend to ensure that the list of files-to-be-revised gets processed each time you execute a new command at the REPL</li><li>when a revision is triggered, the source file(s) are re-parsed, and a diff between the cached version and the new version is created. <code>eval</code> the diff in the appropriate module(s).</li><li>replace the cached version of each source file with the new version, so that further changes are <code>diff</code>ed against the most recent update.</li></ul><h2><a class="nav-anchor" id="The-structure-of-Revise&#39;s-internal-representation-1" href="#The-structure-of-Revise&#39;s-internal-representation-1">The structure of Revise&#39;s internal representation</a></h2><p><img src="../figures/diagram.png" alt="diagram"/></p><p><strong>Figure notes</strong>: Nodes represent primary objects in Julia&#39;s compilation pipeline. Arrows and their labels represent functions or data structures that allow you to move from one node to another. Red (&quot;destructive&quot;) paths force recompilation of dependent functions.</p><p>Revise bridges between text files (your source code) and compiled code. Revise consequently maintains data structures that parallel Julia&#39;s own internal processing of code. When dealing with a source-code file, you start with strings, parse them to obtain Julia expressions, evaluate them to obtain Julia objects, and (where appropriate, e.g., for methods) compile them to machine code. This will be called the <em>forward workflow</em>. Revise sets up a few key structures that allow it to progress from files to modules to Julia expressions and types.</p><p>Revise also sets up a <em>backward workflow</em>, proceeding from compiled code to Julia types back to Julia expressions. This workflow is useful, for example, when dealing with errors: the stack traces displayed by Julia link from the compiled code back to the source files. To make this possible, Julia builds &quot;breadcrumbs&quot; into compiled code that store the filename and line number at which each expression was found. However, these links are static, meaning they are set up once (when the code is compiled) and are not updated when the source file changes. Because trivial manipulations to source files (e.g., the insertion of blank lines and/or comments) can change the line number of an expression without necessitating its recompilation, Revise implements a way of correcting these line numbers before they are displayed to the user. The same problem presents when using a <a href="https://julialang.org/blog/2019/03/debuggers">debugger</a>, in that one wants the debugger to display the correct code (at the correct line number) even after modifications have been made to the file. This capability requires that Revise proceed backward from the compiled objects to something resembling the original text file.</p><h3><a class="nav-anchor" id="Terminology-1" href="#Terminology-1">Terminology</a></h3><p>A few convenience terms are used throughout: <em>definition</em>, <em>signature-expression</em>, and <em>signature-type</em>. These terms are illustrated using the following example:</p><p><pre><code class="language-julia">function <mark>print_item(io::IO, item, ntimes::Integer=1, pre::String="")</mark>
    print(io, pre)
    for i = 1:ntimes
        print(io, item)
    end
end</code></pre></p><p>This represents the <em>definition</em> of a method. Definitions are stored as expressions, using a <a href="../dev_reference/#Revise.RelocatableExpr"><code>Revise.RelocatableExpr</code></a>. The highlighted portion is the <em>signature-expression</em>, specifying the name, argument names and their types, and (if applicable) type-parameters of the method.</p><p>From the signature-expression we can generate one or more <em>signature-types</em>. Since this function has two default arguments, this signature-expression generates three signature-types, each corresponding to a different valid way of calling this method:</p><pre><code class="language-julia">Tuple{typeof(print_item),IO,Any}                    # print_item(io, item)
Tuple{typeof(print_item),IO,Any,Integer}            # print_item(io, item, 2)
Tuple{typeof(print_item),IO,Any,Integer,String}     # print_item(io, item, 2, &quot;  &quot;)</code></pre><p>In Revise&#39;s internal code, a definition is often represented with a variable <code>def</code>, and a signature-type with <code>sigt</code>. Recent versions of Revise do not make extensive use of signature expressions.</p><h3><a class="nav-anchor" id="Computing-signatures-1" href="#Computing-signatures-1">Computing signatures</a></h3><p>Since version 2.0, Revise works primarily with lowered-code representations, specifically using the lowered code to compute method signatures (if you don&#39;t know about lowered code, see <a href="https://juliadebug.github.io/JuliaInterpreter.jl/stable/ast/">this tutorial</a>). There are several reasons that make this an attractive approach, of which the most important are:</p><ul><li>keyword-argument methods get &quot;expanded&quot; to multiple methods handling various ways of populating the arguments. The lowered code lists all of them, which ensures that Revise knows about them all. (There are some challenges regarding &quot;gensymmed&quot; names, see <a href="https://github.com/JuliaDebug/LoweredCodeUtils.jl">LoweredCodeUtils</a> and <a href="https://github.com/JuliaLang/julia/issues/30908">julia#30908</a>, but in short LoweredCodeUtils &quot;fixes&quot; those difficulties.)</li><li>for methods generated by code, the only really reliable mechanism to compute all the signatures is to step through the code that generates the methods. That is performed using <a href="https://github.com/JuliaDebug/JuliaInterpreter.jl">JuliaInterpreter</a>.</li></ul><p>As an example, suppose the following code is part of your module definition:</p><pre><code class="language-none">for T in (Float16, Float32, Float64)
    @eval sizefloat(x::$T) = sizeof($T)
end</code></pre><div class="admonition clarification"><div class="admonition-title">Clarification</div><div class="admonition-text"><p>This is equivalent to the following explicit definitions:</p><pre><code class="language-none">sizefloat(x::Float16) = 2
sizefloat(x::Float32) = 4
sizefloat(x::Float64) = 8</code></pre></div></div><p>If you replace the loop with <code>for T in (Float32, Float64)</code>, then Revise should delete the method for <code>Float16</code>. But this implies that Revise can deduce all the method-signatures created by this block, which essentially requires &quot;simulating&quot; the block that defines the methods. (In simple cases there are other approaches, but for <a href="https://github.com/JuliaLang/julia/blob/c7e4b9929b3b6ee89d47ce1320ef2de14c4ecf85/base/atomics.jl#L415-L430">complex cases</a> stepping through the code seems to be the only viable answer.)</p><p>Because lowered code is far simpler than ordinary Julia code, it is much easier to interpret. Let&#39;s look briefly at a method definition:</p><pre><code class="language-none">floatwins(x::AbstractFloat, y::Integer) = x</code></pre><p>which has lowered representation approximately equal to</p><pre><code class="language-none">CodeInfo(
│        $(Expr(:method, :floatwins))
│   %2 = Core.Typeof(floatwins)
│   %3 = Core.svec(%2, AbstractFloat, Integer)
│   %4 = Core.svec()
│   %5 = Core.svec(%3, %4)
│        $(Expr(:method, :floatwins, :(%5), CodeInfo(quote
    return x
end)))
└──      return floatwins
)</code></pre><p>(I&#39;ve edited this lightly for clarity.) As one steps through this, the first line tells us we&#39;re about to define a method for the function <code>floatwins</code>. Lines 2-5 compute the signature, in the representation <code>svec(sig, params)</code>, where here <code>sig = svec(typeof(floatwins), AbstractFloat, Integer)</code> and <code>params = svec()</code>. (This example has no type parameters, which is why <code>params</code> is empty.)</p><p>What Revise does is steps through the first 5 of these lines, and when it encounters the <code>Expr(:method, :floatwins, :(%5), CodeInfo(...))</code> statement, it pulls out the signature (the <code>%5</code>, which refers to the result computed on the 5th line) and records this as a method generated by this block of code. (It does not, however, evaluate the <code>Expr(:method, ...)</code> expression as a whole, because that would force it to be recompiled.) Stepping through this code ensures that Revise can compute the exact signature, no matter how this method is defined at the level of ordinary Julia code.</p><p>Unfortunately, modules sometimes contain code blocks that perhaps shouldn&#39;t be interpreted:</p><pre><code class="language-julia">init_c_library()     # library crashes if we call this twice</code></pre><p>Starting with version 2.3, Revise attempts to avoid interpreting any code not necessary for signature computation. If you are just tracking changes, Revise will skip over such blocks; if you&#39;re loading a file with <code>includet</code> for the first time, Revise will execute such blocks in compiled mode.</p><p>Revise achieves this by computing <a href="../dev_reference/#Revise.BackEdges"><code>Revise.BackEdges</code></a>, essentially a set of links encoding the dependencies among different lines of the lowered code. For the <code>floatwins</code> example above, the backedges would represent the fact that line 2 has one direct dependant, line 3 (which uses <code>%2</code>), that lines 3 and 4 both have line 5 as their dependents, and line 5 has line 6 as a dependent.  As a consequence, to (nearly) execute line 6, we have to execute lines 2-5, because they set up the signature. If an interdependent block doesn&#39;t contain any <code>:method</code> or related (<code>:struct_type</code>, <code>:eval</code>) expressions, then it doesn&#39;t need to interpret the block at all.</p><p>As should be evident, the lowered code makes it much easier to analyze the graph of these dependencies.  There are, however, a few tricky cases. For example, any code inside an <code>@eval</code> might, or might not, expand into lowered code that contains a <code>:method</code> expression.  Because Revise can&#39;t reliably predict what it will look like after expansion, Revise will execute any code in (or needed for) an <code>@eval</code> block. As a consequence, even after version 2.3 Revise may sometimes interpret more code than is strictly necessary.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If Revise executes code that still shouldn&#39;t be run twice, one good solution is to put all initialization inside your module&#39;s <a href="https://docs.julialang.org/en/latest/manual/modules/#Module-initialization-and-precompilation-1"><code>__init__</code> function</a>. For files that you track with <code>includet</code>, you can also split &quot;code that defines methods&quot; into a separate file from &quot;code that does work,&quot; and have Revise track only the method-defining file. However, starting with version 2.3 Revise should be fairly good at doing this on its own; such manual interventions should not be necessary in most cases.</p></div></div><h3><a class="nav-anchor" id="Core-data-structures-and-representations-1" href="#Core-data-structures-and-representations-1">Core data structures and representations</a></h3><p>Two &quot;maps&quot; are central to Revise&#39;s inner workings: <code>ExprsSigs</code> maps link definition=&gt;signature-types (the forward workflow), while <code>CodeTracking</code> (specifically, its internal variable <code>method_info</code>) links from signature-type=&gt;definition (the backward workflow). Concretely, <code>CodeTracking.method_info</code> is just an <code>IdDict</code> mapping <code>sigt=&gt;(locationinfo, def)</code>. Of note, a stack frame typically contains a link to a method, which stores the equivalent of <code>sigt</code>; consequently, this information allows one to look up the corresponding <code>locationinfo</code> and <code>def</code>. (When methods move, the location information stored by CodeTracking gets updated by Revise.)</p><p>Some additional notes about Revise&#39;s <code>ExprsSigs</code> maps:</p><ul><li>For expressions that do not define a method, it is just <code>def=&gt;nothing</code></li><li>For expressions that do define a method, it is <code>def=&gt;[sigt1, ...]</code>. <code>[sigt1, ...]</code> is the list of signature-types generated from <code>def</code> (often just one, but more in the case of methods with default arguments or keyword arguments).</li><li>They are represented as an <code>OrderedDict</code> so as to preserve the sequence in which expressions occur in the file. This can be important particularly for updating macro definitions, which affect the expansion of later code. The order is maintained so as to match the current ordering of the source-file, which is not necessarily the same as the ordering when these expressions were last <code>eval</code>ed.</li><li>Each key in the map (the definition <code>RelocatableExpr</code>) is the most recently <code>eval</code>ed version of the expression. This has an important consequence: the line numbers in the <code>def</code> (which are still present, even though not used for equality comparisons) correspond to the ones in compiled code. Any discrepancy with the current line numbers in the file is handled through updates to the location information stored by <code>CodeTracking</code>.</li></ul><p><code>ExprsSigs</code> are organized by module and then file, so that one can map <code>filename</code>=&gt;<code>module</code>=&gt;<code>def</code>=&gt;<code>sigts</code>. Importantly, single-file modules can be &quot;reconstructed&quot; from the keys of the corresponding <code>ExprsSigs</code> (and multi-file modules from a collection of such items), since they hold the complete ordered set of expressions that would be <code>eval</code>ed to define the module.</p><p>The global variable that holds all this information is <a href="../dev_reference/#Revise.pkgdatas"><code>Revise.pkgdatas</code></a>, organized into a dictionary of <a href="../dev_reference/#Revise.PkgData"><code>Revise.PkgData</code></a> objects indexed by Base Julia&#39;s <code>PkgId</code> (a unique identifier for packages).</p><h3><a class="nav-anchor" id="An-example-1" href="#An-example-1">An example</a></h3><p>Consider a module, <code>Items</code>, defined by the following two source files:</p><p><code>Items.jl</code>:</p><pre><code class="language-julia">__precompile__(false)

module Items

include(&quot;indents.jl&quot;)

function print_item(io::IO, item, ntimes::Integer=1, pre::String=indent(item))
    print(io, pre)
    for i = 1:ntimes
        print(io, item)
    end
end

end</code></pre><p><code>indents.jl</code>:</p><pre><code class="language-julia">indent(::UInt16) = 2
indent(::UInt8)  = 4</code></pre><p>If you create this as a mini-package and then say <code>using Revise, Items</code>, you can start examining internal variables in the following manner:</p><pre><code class="language-julia">julia&gt; id = Base.PkgId(Items)
Items [b24a5932-55ed-11e9-2a88-e52f99e65a0d]

julia&gt; pkgdata = Revise.pkgdatas[id]
PkgData(Items [b24a5932-55ed-11e9-2a88-e52f99e65a0d]:
  &quot;src/Items.jl&quot;: FileInfo(Main=&gt;ExprsSigs(&lt;1 expressions&gt;, &lt;0 signatures&gt;), Items=&gt;ExprsSigs(&lt;2 expressions&gt;, &lt;3 signatures&gt;), )
  &quot;src/indents.jl&quot;: FileInfo(Items=&gt;ExprsSigs(&lt;2 expressions&gt;, &lt;2 signatures&gt;), )</code></pre><p>(Your specific UUID may differ.)</p><p>Path information is stored in <code>pkgdata.info</code>:</p><pre><code class="language-julia">julia&gt; pkgdata.info
PkgFiles(Items [b24a5932-55ed-11e9-2a88-e52f99e65a0d]):
  basedir: &quot;/tmp/pkgs/Items&quot;
  files: [&quot;src/Items.jl&quot;, &quot;src/indents.jl&quot;]</code></pre><p><code>basedir</code> is the only part using absolute paths; everything else is encoded relative to that location. This facilitates, e.g., switching between <code>develop</code> and <code>add</code> mode in the package manager.</p><p><code>src/indents.jl</code> is particularly simple:</p><pre><code class="language-julia">julia&gt; pkgdata.fileinfos[2]
FileInfo(Items=&gt;ExprsSigs with the following expressions:
  :(indent(::UInt16) = begin
          2
      end)
  :(indent(::UInt8) = begin
          4
      end), )</code></pre><p>This is just a summary; to see the actual <code>def=&gt;sigts</code> map, do the following:</p><pre><code class="language-julia">julia&gt; pkgdata.fileinfos[2].modexsigs[Items]
OrderedCollections.OrderedDict{Revise.RelocatableExpr,Union{Nothing, Array{Any,1}}} with 2 entries:
  :(indent(::UInt16) = begin…                       =&gt; Any[Tuple{typeof(indent),UInt16}]
  :(indent(::UInt8) = begin…                        =&gt; Any[Tuple{typeof(indent),UInt8}]</code></pre><p>These are populated now because we specified <code>__precompile__(false)</code>, which forces Revise to defensively parse all expressions in the package in case revisions are made at some future point. For precompiled packages, each <code>pkgdata.fileinfos[i]</code> can instead rely on the <code>cachefile</code> (another field stored in the <a href="../dev_reference/#Revise.FileInfo"><code>Revise.FileInfo</code></a>) as a record of the state of the file at the time the package was loaded; as a consequence, Revise can defer parsing the source file(s) until they are updated.</p><p><code>Items.jl</code> is represented with a bit more complexity, <code>&quot;Items.jl&quot;=&gt;Dict(Main=&gt;map1, Items=&gt;map2)</code>. This is because <code>Items.jl</code> contains one expression (the <code>__precompile__</code> statement) that is <code>eval</code>ed in <code>Main</code>, and other expressions that are <code>eval</code>ed in <code>Items</code>.</p><h3><a class="nav-anchor" id="Revisions-and-computing-diffs-1" href="#Revisions-and-computing-diffs-1">Revisions and computing diffs</a></h3><p>When the file system notifies Revise that a file has been modified, Revise re-parses the file and assigns the expressions to the appropriate modules, creating a <a href="../dev_reference/#Revise.ModuleExprsSigs"><code>Revise.ModuleExprsSigs</code></a> <code>mexsnew</code>. It then compares <code>mexsnew</code> against <code>mexsref</code>, the reference object that is synchronized to code as it was <code>eval</code>ed. The following actions are taken:</p><ul><li>if a <code>def</code> entry in <code>mexsref</code> is equal to one in <code>mexsnew</code>, the expression is &quot;unchanged&quot; except possibly for line number. The <code>locationinfo</code> in <code>CodeTracking</code> is updated as needed.</li><li>if a <code>def</code> entry in <code>mexsref</code> is not present in <code>mexsnew</code>, that entry is deleted and any corresponding methods are also deleted.</li><li>if a <code>def</code> entry in <code>mexsnew</code> is not present in <code>mexsref</code>, it is <code>eval</code>ed and then added to <code>mexsref</code>.</li></ul><p>Technically, a new <code>mexsref</code> is generated every time to ensure that the expressions are ordered as in <code>mexsnew</code>; however, conceptually this is better thought of as an updating of <code>mexsref</code>, after which <code>mexsnew</code> is discarded.</p><p>Note that one consequence is that modifying a method causes two actions, the deletion of the original followed by <code>eval</code>ing a new version. During revision, all method deletions are performed first, followed by all the new <code>eval</code>ed methods. This ensures that if a method gets moved from <code>fileB.jl</code> to <code>fileA.jl</code>, Revise doesn&#39;t mistakenly redefine and then delete the method simply because <code>fileA.jl</code> got processed before <code>fileB.jl</code>.</p><h3><a class="nav-anchor" id="Internal-API-1" href="#Internal-API-1">Internal API</a></h3><p>You can find more detail about Revise&#39;s inner workings in the <a href="../dev_reference/#Developer-reference-1">Developer reference</a>.</p><footer><hr/><a class="previous" href="../debugging/"><span class="direction">Previous</span><span class="title">Debugging Revise</span></a><a class="next" href="../user_reference/"><span class="direction">Next</span><span class="title">User reference</span></a></footer></article></body></html>
